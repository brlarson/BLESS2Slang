// #Sireum

// generated by BLESS v3.2.1 at Tue Nov 14 03:54:35 CST 2023 from Rx::Settings.imp

package bless.Rx

import org.sireum._
import org.sireum.S64._  //type for native time (in ms) and integers
import org.sireum.F64._  //type for quantities
import art.Art           // for .time() timestamp
import bless._
// import types created for data components
import bless.PACE_Data.rf
import bless.PACE_Data.percent
import bless.PACE_Data.Rx
import bless.mark.AtrialMarker
import bless.PACE_Data.ms
import bless.mark.ExtraordinaryMarker
import bless.PACE_Data.CCcount
import bless.PACE_Data.milliG
import bless.PACE_Data.second
import bless.BLESS_Types.flag
import bless.mark.VentricularlMarker

object Settings_imp_pgp_stg 
  {
  @enum object CompleteStates 
    {
    "init_state" //initial state
    "run_state" 
    }
  //  execution states: [none]
  //  final states: [none]

  var currentState: CompleteStates.Type = CompleteStates.init_state

  // no local variables
  var dispatch_status: Set[art.Art.PortId] = Set.empty  //local copy of Dispatch_Status

  def Initialize_Entrypoint(api: Settings_imp_Initialization_Api): Unit = 
    {
    api.logDebug("executing Initialize_Entrypoint of Settings_imp_pgp_stg")
    if ( true )
      { do_go_init(api) }
    //  set durations of timeouts in Bridge
    }  //end of Initialize_Entrypoint

  def Compute_Entrypoint(api: Settings_imp_Operational_Api, Dispatch_Status: Set[art.Art.PortId]): B = 
    {
    dispatch_status = Dispatch_Status  // save local copy of dispatch status
    api.logDebug("executing Compute_Entrypoint of Settings_imp_pgp_stg")
    api.logDebug(s"Dispatch_Status = ${dispatch_status.elements}")
    api.logDebug(s"current complete state = ${currentState}")
    var retval : B = F
    currentState match
      {
      case Settings_imp_pgp_stg.CompleteStates.init_state =>
        if ( true )
          { //initial state case needed for complete match
            retval = T }
      case Settings_imp_pgp_stg.CompleteStates.run_state =>
        if ( dispatch_status.contains(api.settings_Id) )
          { do_operate_run(api)
            retval = T }
      }
    return retval
    }  //end of Compute_Entrypoint

  def Finalize_Entrypoint(api: Settings_imp_Operational_Api): Unit = 
    {
    }  //end of Finalize_Entrypoint

  // methods for transitions leaving initial state  
  def do_go_init(api: Settings_imp_Initialization_Api): Unit = 
    {
    api.logDebug("executing go")

    api.put_lrl(ms(f64"1000"))
    api.put_url(ms(f64"500"))
    api.put_av(ms(f64"150"))
    api.put_savo(ms(f64"20"))
    api.put_act(milliG(f64"25"))
    api.put_vrp(ms(f64"200"))
    api.put_arp(ms(f64"80"))
    api.put_pvarp(ms(f64"200"))
    api.put_pv(flag(T))
    api.put_sv(flag(T))
    api.put_pa(flag(T))
    api.put_sa(flag(T))
    api.put_inhibit(flag(T))
    api.put_track(flag(T))
    api.put_hy(ms(f64"10"))
    api.put_rr(flag(T))
    api.put_rf(rf(f64"10.0"))
    api.put_msr(ms(f64"600"))
    api.put_min_av(ms(f64"100"))
    api.put_ex_pvarp(ms(f64"250"))
    api.put_rt(second(f64"12"))
    api.put_ct(second(f64"60"))
    api.put_atr_enable(flag(F))
    api.put_atr_duration(CCcount(s64"30"))
    api.put_fb_time(second(f64"60"))
    api.put_drs(percent(f64"20.0"))
    api.put_urs(percent(f64"30.0"))
    //set currentState to destination complete state run
    currentState = Settings_imp_pgp_stg.CompleteStates.run_state
    }  //end of do_go_init

  // methods for transitions leaving complete states  
  def do_operate_run(api: Settings_imp_Operational_Api): Unit = 
    {
    api.logDebug("executing operate")

    //no action
    //set currentState to destination complete state run
    currentState = Settings_imp_pgp_stg.CompleteStates.run_state
    }  //end of do_operate_run

  // methods for execution states

  def contains(isz : ISZ[Art.PortId], elt : Art.PortId) : B =
    { for ( i <- isz )
      { if (i == elt) { return T } }
    return F
    }
  }

