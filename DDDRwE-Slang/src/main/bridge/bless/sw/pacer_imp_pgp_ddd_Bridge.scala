// #Sireum

package bless.sw

import org.sireum._
import art._
import bless._
import bless.sw.{pacer_imp_pgp_ddd => component}
import org.sireum.S64._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

@datatype class pacer_imp_pgp_ddd_Bridge(
  val id: Art.BridgeId,
  val name: String,
  val dispatchProtocol: DispatchPropertyProtocol,
  val dispatchTriggers: Option[ISZ[Art.PortId]],

  tna: Port[BLESS_Types.flag],
  tnv: Port[BLESS_Types.flag],
  last_v_was_vs: Port[BLESS_Types.flag],
  min_cci: Port[PACE_Data.ms],
  max_cci: Port[PACE_Data.ms],
  atr_max_cci: Port[PACE_Data.ms],
  dav: Port[PACE_Data.ms],
  fb: Port[BLESS_Types.flag],
  lrl: Port[PACE_Data.ms],
  url: Port[PACE_Data.ms],
  av: Port[PACE_Data.ms],
  savo: Port[PACE_Data.ms],
  act: Port[PACE_Data.milliG],
  vrp: Port[PACE_Data.ms],
  arp: Port[PACE_Data.ms],
  pvarp: Port[PACE_Data.ms],
  ex_pvarp: Port[PACE_Data.ms],
  hy: Port[PACE_Data.ms],
  min_av: Port[PACE_Data.ms],
  pv: Port[BLESS_Types.flag],
  sv: Port[BLESS_Types.flag],
  pa: Port[BLESS_Types.flag],
  sa: Port[BLESS_Types.flag],
  inhibit: Port[BLESS_Types.flag],
  track: Port[BLESS_Types.flag],
  cci: Port[PACE_Data.ms],
  a: Port[art.Empty],
  v: Port[art.Empty],
  ap: Port[art.Empty],
  vp: Port[art.Empty],
  as: Port[art.Empty],
  at: Port[art.Empty],
  vs: Port[art.Empty],
  pvc: Port[art.Empty],
  ras: Port[art.Empty],
  rvs: Port[art.Empty]
  ) extends Bridge {

  val ports : Bridge.Ports = Bridge.Ports(
    dataIns = ISZ[art.UPort](tna,
                             tnv,
                             min_cci,
                             max_cci,
                             atr_max_cci,
                             dav,
                             fb,
                             lrl,
                             url,
                             av,
                             savo,
                             act,
                             vrp,
                             arp,
                             pvarp,
                             ex_pvarp,
                             hy,
                             min_av,
                             pv,
                             sv,
                             pa,
                             sa,
                             inhibit,
                             track),

    dataOuts = ISZ[art.UPort](last_v_was_vs),

    eventIns = ISZ[art.UPort](a,
                              v),

    eventOuts = ISZ[art.UPort](cci,
                               ap,
                               vp,
                               as,
                               at,
                               vs,
                               pvc,
                               ras,
                               rvs)
  )

  val initialization_api : pacer_imp_Initialization_Api = {
    val api = pacer_imp_Initialization_Api(
      id,
      tna.id,
      tnv.id,
      last_v_was_vs.id,
      min_cci.id,
      max_cci.id,
      atr_max_cci.id,
      dav.id,
      fb.id,
      lrl.id,
      url.id,
      av.id,
      savo.id,
      act.id,
      vrp.id,
      arp.id,
      pvarp.id,
      ex_pvarp.id,
      hy.id,
      min_av.id,
      pv.id,
      sv.id,
      pa.id,
      sa.id,
      inhibit.id,
      track.id,
      cci.id,
      a.id,
      v.id,
      ap.id,
      vp.id,
      as.id,
      at.id,
      vs.id,
      pvc.id,
      ras.id,
      rvs.id
    )
    pacer_imp_pgp_ddd_Bridge.c_initialization_api = Some(api)
    api
  }

  val operational_api : pacer_imp_Operational_Api = {
    val api = pacer_imp_Operational_Api(
      id,
      tna.id,
      tnv.id,
      last_v_was_vs.id,
      min_cci.id,
      max_cci.id,
      atr_max_cci.id,
      dav.id,
      fb.id,
      lrl.id,
      url.id,
      av.id,
      savo.id,
      act.id,
      vrp.id,
      arp.id,
      pvarp.id,
      ex_pvarp.id,
      hy.id,
      min_av.id,
      pv.id,
      sv.id,
      pa.id,
      sa.id,
      inhibit.id,
      track.id,
      cci.id,
      a.id,
      v.id,
      ap.id,
      vp.id,
      as.id,
      at.id,
      vs.id,
      pvc.id,
      ras.id,
      rvs.id
    )
    pacer_imp_pgp_ddd_Bridge.c_operational_api = Some(api)
    api
  }

  val entryPoints : Bridge.EntryPoints =
    pacer_imp_pgp_ddd_Bridge.EntryPoints(
      id,

      tna.id,
      tnv.id,
      last_v_was_vs.id,
      min_cci.id,
      max_cci.id,
      atr_max_cci.id,
      dav.id,
      fb.id,
      lrl.id,
      url.id,
      av.id,
      savo.id,
      act.id,
      vrp.id,
      arp.id,
      pvarp.id,
      ex_pvarp.id,
      hy.id,
      min_av.id,
      pv.id,
      sv.id,
      pa.id,
      sa.id,
      inhibit.id,
      track.id,
      cci.id,
      a.id,
      v.id,
      ap.id,
      vp.id,
      as.id,
      at.id,
      vs.id,
      pvc.id,
      ras.id,
      rvs.id,

      dispatchTriggers,

      initialization_api,
      operational_api)
}

object pacer_imp_pgp_ddd_Bridge {

  var c_initialization_api: Option[pacer_imp_Initialization_Api] = None()
  var c_operational_api: Option[pacer_imp_Operational_Api] = None()
  // I'm a companion object block

  def contains(isz : ISZ[Art.PortId], elt : Art.PortId) : B =
    { for ( i <- isz )
      { if (i == elt) { return T } }
    return F
    }

  var event_set : Set[Art.PortId] = Set.empty[Art.PortId]

  var timeout_id : Art.PortId = Art.PortId.fromZ(Art.numPorts - 4)

  //timeout variables
  val timeout_as_dav_savo_ID : Art.PortId = timeout_id+Art.PortId.fromZ(1)
  var timeout_as_dav_savo_Duration : Art.Time = s64"0"
  val timeout_vp_vs_va_interval_ID : Art.PortId = timeout_id+Art.PortId.fromZ(2)
  var timeout_vp_vs_va_interval_Duration : Art.Time = s64"0"
  val timeout_vp_vs_max_CCI_ID : Art.PortId = timeout_id+Art.PortId.fromZ(3)
  var timeout_vp_vs_max_CCI_Duration : Art.Time = s64"0"


  //timeout callback classes
  @datatype class Callback_timeout_as_dav_savo(ep : EntryPoints) extends TimerCallback
    {
    override def callback(): Unit = { ep.timeout_as_dav_savo_expires( mc = this ) }
    }
  @datatype class Callback_timeout_vp_vs_va_interval(ep : EntryPoints) extends TimerCallback
    {
    override def callback(): Unit = { ep.timeout_vp_vs_va_interval_expires( mc = this ) }
    }
  @datatype class Callback_timeout_vp_vs_max_CCI(ep : EntryPoints) extends TimerCallback
    {
    override def callback(): Unit = { ep.timeout_vp_vs_max_CCI_expires( mc = this ) }
    }


  @datatype class EntryPoints(
    pacer_imp_pgp_ddd_BridgeId : Art.BridgeId,
    tna_Id : Art.PortId,
    tnv_Id : Art.PortId,
    last_v_was_vs_Id : Art.PortId,
    min_cci_Id : Art.PortId,
    max_cci_Id : Art.PortId,
    atr_max_cci_Id : Art.PortId,
    dav_Id : Art.PortId,
    fb_Id : Art.PortId,
    lrl_Id : Art.PortId,
    url_Id : Art.PortId,
    av_Id : Art.PortId,
    savo_Id : Art.PortId,
    act_Id : Art.PortId,
    vrp_Id : Art.PortId,
    arp_Id : Art.PortId,
    pvarp_Id : Art.PortId,
    ex_pvarp_Id : Art.PortId,
    hy_Id : Art.PortId,
    min_av_Id : Art.PortId,
    pv_Id : Art.PortId,
    sv_Id : Art.PortId,
    pa_Id : Art.PortId,
    sa_Id : Art.PortId,
    inhibit_Id : Art.PortId,
    track_Id : Art.PortId,
    cci_Id : Art.PortId,
    a_Id : Art.PortId,
    v_Id : Art.PortId,
    ap_Id : Art.PortId,
    vp_Id : Art.PortId,
    as_Id : Art.PortId,
    at_Id : Art.PortId,
    vs_Id : Art.PortId,
    pvc_Id : Art.PortId,
    ras_Id : Art.PortId,
    rvs_Id : Art.PortId,
    dispatchTriggers : Option[ISZ[Art.PortId]],
    initialization_api: pacer_imp_Initialization_Api,
    operational_api: pacer_imp_Operational_Api) extends Bridge.EntryPoints {

    val dataInPortIds: ISZ[Art.PortId] = IS(tna_Id,
                                            tnv_Id,
                                            min_cci_Id,
                                            max_cci_Id,
                                            atr_max_cci_Id,
                                            dav_Id,
                                            fb_Id,
                                            lrl_Id,
                                            url_Id,
                                            av_Id,
                                            savo_Id,
                                            act_Id,
                                            vrp_Id,
                                            arp_Id,
                                            pvarp_Id,
                                            ex_pvarp_Id,
                                            hy_Id,
                                            min_av_Id,
                                            pv_Id,
                                            sv_Id,
                                            pa_Id,
                                            sa_Id,
                                            inhibit_Id,
                                            track_Id)

    val eventInPortIds: ISZ[Art.PortId] = IS(a_Id,
                                             v_Id)

    val dataOutPortIds: ISZ[Art.PortId] = IS(last_v_was_vs_Id)

    val eventOutPortIds: ISZ[Art.PortId] = IS(cci_Id,
                                              ap_Id,
                                              vp_Id,
                                              as_Id,
                                              at_Id,
                                              vs_Id,
                                              pvc_Id,
                                              ras_Id,
                                              rvs_Id)

    //timeout callback methods
    def timeout_as_dav_savo_expires(mc: Callback_timeout_as_dav_savo): Unit =
      {
      operational_api.logDebug("timeout_as_dav_savo expires")
      event_set = event_set + timeout_as_dav_savo_ID
      compute()
      }
    def timeout_vp_vs_va_interval_expires(mc: Callback_timeout_vp_vs_va_interval): Unit =
      {
      operational_api.logDebug("timeout_vp_vs_va_interval expires")
      event_set = event_set + timeout_vp_vs_va_interval_ID
      compute()
      }
    def timeout_vp_vs_max_CCI_expires(mc: Callback_timeout_vp_vs_max_CCI): Unit =
      {
      operational_api.logDebug("timeout_vp_vs_max_CCI expires")
      event_set = event_set + timeout_vp_vs_max_CCI_ID
      compute()
      }

    def initialise(): Unit = {
      // i'm an initialize body
        initialization_api.logDebug("pacer_imp_pgp_ddd_Bridge.initialise()")  
        component.Initialize_Entrypoint(initialization_api)
        if ( Art.observeOutPortVariable(as_Id).nonEmpty )
          { ArtTimer.scheduleTrait("timeout_as_dav_savo", T, timeout_as_dav_savo_Duration, Callback_timeout_as_dav_savo(this)) }
          if ( Art.observeOutPortVariable(vp_Id).nonEmpty | Art.observeOutPortVariable(vs_Id).nonEmpty )
          { ArtTimer.scheduleTrait("timeout_vp_vs_va_interval", T, timeout_vp_vs_va_interval_Duration, Callback_timeout_vp_vs_va_interval(this)) }
          if ( Art.observeOutPortVariable(vp_Id).nonEmpty | Art.observeOutPortVariable(vs_Id).nonEmpty )
          { ArtTimer.scheduleTrait("timeout_vp_vs_max_CCI", T, timeout_vp_vs_max_CCI_Duration, Callback_timeout_vp_vs_max_CCI(this)) }
        Art.sendOutput(eventOutPortIds, dataOutPortIds)
    }

    def compute(): Unit = {
      // i'm a compute body
        operational_api.logDebug("pacer_imp_pgp_ddd_Bridge.compute()")  
        val EventTriggered(receivedEvents) = Art.dispatchStatus(pacer_imp_pgp_ddd_BridgeId)
        event_set = event_set ++ receivedEvents  
        Art.receiveInput(eventInPortIds, dataInPortIds)
        val dispatched : B = { component.Compute_Entrypoint(operational_api, event_set) }
        if (dispatched) { event_set = Set.empty[Art.PortId] }
        if ( Art.observeOutPortVariable(as_Id).nonEmpty )
          { ArtTimer.scheduleTrait("timeout_as_dav_savo", T, timeout_as_dav_savo_Duration, Callback_timeout_as_dav_savo(this)) }
          if ( Art.observeOutPortVariable(vp_Id).nonEmpty | Art.observeOutPortVariable(vs_Id).nonEmpty )
          { ArtTimer.scheduleTrait("timeout_vp_vs_va_interval", T, timeout_vp_vs_va_interval_Duration, Callback_timeout_vp_vs_va_interval(this)) }
          if ( Art.observeOutPortVariable(vp_Id).nonEmpty | Art.observeOutPortVariable(vs_Id).nonEmpty )
          { ArtTimer.scheduleTrait("timeout_vp_vs_max_CCI", T, timeout_vp_vs_max_CCI_Duration, Callback_timeout_vp_vs_max_CCI(this)) }
        Art.sendOutput(eventOutPortIds, dataOutPortIds)
    }

    def activate(): Unit = {
      // i'm an activate body
    }

    def deactivate(): Unit = {
      // i'm a deactivate body
    }

    def finalise(): Unit = {
      // i'm a finalize body
      Art.receiveInput(eventInPortIds, dataInPortIds)
      component.Finalize_Entrypoint(operational_api)
    }

    def recover(): Unit = {
      // i'm a recover body
    }

    override
    def testInitialise(): Unit = {
      // i'm an initialize body
        initialization_api.logDebug("pacer_imp_pgp_ddd_Bridge.initialise()")  
        component.Initialize_Entrypoint(initialization_api)
        if ( Art.observeOutPortVariable(as_Id).nonEmpty )
          { ArtTimer.scheduleTrait("timeout_as_dav_savo", T, timeout_as_dav_savo_Duration, Callback_timeout_as_dav_savo(this)) }
          if ( Art.observeOutPortVariable(vp_Id).nonEmpty | Art.observeOutPortVariable(vs_Id).nonEmpty )
          { ArtTimer.scheduleTrait("timeout_vp_vs_va_interval", T, timeout_vp_vs_va_interval_Duration, Callback_timeout_vp_vs_va_interval(this)) }
          if ( Art.observeOutPortVariable(vp_Id).nonEmpty | Art.observeOutPortVariable(vs_Id).nonEmpty )
          { ArtTimer.scheduleTrait("timeout_vp_vs_max_CCI", T, timeout_vp_vs_max_CCI_Duration, Callback_timeout_vp_vs_max_CCI(this)) }
        Art.sendOutput(eventOutPortIds, dataOutPortIds)
    }

    override
    def testCompute(): Unit = {
      // i'm a compute body
        operational_api.logDebug("pacer_imp_pgp_ddd_Bridge.compute()")  
        val EventTriggered(receivedEvents) = Art.dispatchStatus(pacer_imp_pgp_ddd_BridgeId)
        event_set = event_set ++ receivedEvents  
        Art.receiveInput(eventInPortIds, dataInPortIds)
        val dispatched : B = { component.Compute_Entrypoint(operational_api, event_set) }
        if (dispatched) { event_set = Set.empty[Art.PortId] }
        if ( Art.observeOutPortVariable(as_Id).nonEmpty )
          { ArtTimer.scheduleTrait("timeout_as_dav_savo", T, timeout_as_dav_savo_Duration, Callback_timeout_as_dav_savo(this)) }
          if ( Art.observeOutPortVariable(vp_Id).nonEmpty | Art.observeOutPortVariable(vs_Id).nonEmpty )
          { ArtTimer.scheduleTrait("timeout_vp_vs_va_interval", T, timeout_vp_vs_va_interval_Duration, Callback_timeout_vp_vs_va_interval(this)) }
          if ( Art.observeOutPortVariable(vp_Id).nonEmpty | Art.observeOutPortVariable(vs_Id).nonEmpty )
          { ArtTimer.scheduleTrait("timeout_vp_vs_max_CCI", T, timeout_vp_vs_max_CCI_Duration, Callback_timeout_vp_vs_max_CCI(this)) }
        Art.sendOutput(eventOutPortIds, dataOutPortIds)
    }
  }
}