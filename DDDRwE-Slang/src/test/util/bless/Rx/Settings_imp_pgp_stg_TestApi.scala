// #Sireum

package bless.Rx

import org.sireum._
import art.{Art, ArtNative, Empty}
import bless._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun
@msig trait Settings_imp_pgp_stg_TestApi {

  def BeforeEntrypoint(): Unit = {
    Art.initTest(Arch.PG_imp_Instance_pgp_stg)
  }

  def AfterEntrypoint(): Unit = {
    Art.finalizeTest(Arch.PG_imp_Instance_pgp_stg)
  }

  def testCompute(): Unit = {
    Art.manuallyClearOutput()
    Art.testCompute(Arch.PG_imp_Instance_pgp_stg)
  }

  def testInitialise(): Unit = {
    Art.manuallyClearOutput()
    Art.testInitialise(Arch.PG_imp_Instance_pgp_stg)
  }

  /** helper function to set the values of all input ports.
   * @param settings payloads for event data port settings.
   *   ART currently supports single element event data queues so
   *   only the last element of settings will be used
   */
  def put_concrete_inputs(settings : ISZ[PACE_Data.Rx]): Unit = {
    for(v <- settings){
      put_settings(v)
    }
  }


  /** helper function to check Settings_imp_pgp_stg's
   * output ports.  Use named arguments to check subsets of the output ports.
   * @param lrl method that will be called with the value of the outgoing data
   *        port 'lrl'.
   * @param url method that will be called with the value of the outgoing data
   *        port 'url'.
   * @param av method that will be called with the value of the outgoing data
   *        port 'av'.
   * @param savo method that will be called with the value of the outgoing data
   *        port 'savo'.
   * @param act method that will be called with the value of the outgoing data
   *        port 'act'.
   * @param vrp method that will be called with the value of the outgoing data
   *        port 'vrp'.
   * @param arp method that will be called with the value of the outgoing data
   *        port 'arp'.
   * @param pvarp method that will be called with the value of the outgoing data
   *        port 'pvarp'.
   * @param pv method that will be called with the value of the outgoing data
   *        port 'pv'.
   * @param sv method that will be called with the value of the outgoing data
   *        port 'sv'.
   * @param pa method that will be called with the value of the outgoing data
   *        port 'pa'.
   * @param sa method that will be called with the value of the outgoing data
   *        port 'sa'.
   * @param inhibit method that will be called with the value of the outgoing data
   *        port 'inhibit'.
   * @param track method that will be called with the value of the outgoing data
   *        port 'track'.
   * @param hy method that will be called with the value of the outgoing data
   *        port 'hy'.
   * @param rr method that will be called with the value of the outgoing data
   *        port 'rr'.
   * @param rf method that will be called with the value of the outgoing data
   *        port 'rf'.
   * @param msr method that will be called with the value of the outgoing data
   *        port 'msr'.
   * @param min_av method that will be called with the value of the outgoing data
   *        port 'min_av'.
   * @param ex_pvarp method that will be called with the value of the outgoing data
   *        port 'ex_pvarp'.
   * @param rt method that will be called with the value of the outgoing data
   *        port 'rt'.
   * @param ct method that will be called with the value of the outgoing data
   *        port 'ct'.
   * @param atr_enable method that will be called with the value of the outgoing data
   *        port 'atr_enable'.
   * @param atr_duration method that will be called with the value of the outgoing data
   *        port 'atr_duration'.
   * @param fb_time method that will be called with the value of the outgoing data
   *        port 'fb_time'.
   * @param drs method that will be called with the value of the outgoing data
   *        port 'drs'.
   * @param urs method that will be called with the value of the outgoing data
   *        port 'urs'.
   */
  def check_concrete_output(lrl: PACE_Data.ms => B,
                            url: PACE_Data.ms => B,
                            av: PACE_Data.ms => B,
                            savo: PACE_Data.ms => B,
                            act: PACE_Data.milliG => B,
                            vrp: PACE_Data.ms => B,
                            arp: PACE_Data.ms => B,
                            pvarp: PACE_Data.ms => B,
                            pv: BLESS_Types.flag => B,
                            sv: BLESS_Types.flag => B,
                            pa: BLESS_Types.flag => B,
                            sa: BLESS_Types.flag => B,
                            inhibit: BLESS_Types.flag => B,
                            track: BLESS_Types.flag => B,
                            hy: PACE_Data.ms => B,
                            rr: BLESS_Types.flag => B,
                            rf: PACE_Data.rf => B,
                            msr: PACE_Data.ms => B,
                            min_av: PACE_Data.ms => B,
                            ex_pvarp: PACE_Data.ms => B,
                            rt: PACE_Data.second => B,
                            ct: PACE_Data.second => B,
                            atr_enable: BLESS_Types.flag => B,
                            atr_duration: PACE_Data.CCcount => B,
                            fb_time: PACE_Data.second => B,
                            drs: PACE_Data.percent => B,
                            urs: PACE_Data.percent => B): Unit = {
    var testFailures: ISZ[ST] = ISZ()

    val lrlValue: PACE_Data.ms = get_lrl().get
    if(!lrl(lrlValue)) {
      testFailures = testFailures :+ st"'lrl' did not match expected: value of the outgoing data port is ${lrlValue}"
    }
    val urlValue: PACE_Data.ms = get_url().get
    if(!url(urlValue)) {
      testFailures = testFailures :+ st"'url' did not match expected: value of the outgoing data port is ${urlValue}"
    }
    val avValue: PACE_Data.ms = get_av().get
    if(!av(avValue)) {
      testFailures = testFailures :+ st"'av' did not match expected: value of the outgoing data port is ${avValue}"
    }
    val savoValue: PACE_Data.ms = get_savo().get
    if(!savo(savoValue)) {
      testFailures = testFailures :+ st"'savo' did not match expected: value of the outgoing data port is ${savoValue}"
    }
    val actValue: PACE_Data.milliG = get_act().get
    if(!act(actValue)) {
      testFailures = testFailures :+ st"'act' did not match expected: value of the outgoing data port is ${actValue}"
    }
    val vrpValue: PACE_Data.ms = get_vrp().get
    if(!vrp(vrpValue)) {
      testFailures = testFailures :+ st"'vrp' did not match expected: value of the outgoing data port is ${vrpValue}"
    }
    val arpValue: PACE_Data.ms = get_arp().get
    if(!arp(arpValue)) {
      testFailures = testFailures :+ st"'arp' did not match expected: value of the outgoing data port is ${arpValue}"
    }
    val pvarpValue: PACE_Data.ms = get_pvarp().get
    if(!pvarp(pvarpValue)) {
      testFailures = testFailures :+ st"'pvarp' did not match expected: value of the outgoing data port is ${pvarpValue}"
    }
    val pvValue: BLESS_Types.flag = get_pv().get
    if(!pv(pvValue)) {
      testFailures = testFailures :+ st"'pv' did not match expected: value of the outgoing data port is ${pvValue}"
    }
    val svValue: BLESS_Types.flag = get_sv().get
    if(!sv(svValue)) {
      testFailures = testFailures :+ st"'sv' did not match expected: value of the outgoing data port is ${svValue}"
    }
    val paValue: BLESS_Types.flag = get_pa().get
    if(!pa(paValue)) {
      testFailures = testFailures :+ st"'pa' did not match expected: value of the outgoing data port is ${paValue}"
    }
    val saValue: BLESS_Types.flag = get_sa().get
    if(!sa(saValue)) {
      testFailures = testFailures :+ st"'sa' did not match expected: value of the outgoing data port is ${saValue}"
    }
    val inhibitValue: BLESS_Types.flag = get_inhibit().get
    if(!inhibit(inhibitValue)) {
      testFailures = testFailures :+ st"'inhibit' did not match expected: value of the outgoing data port is ${inhibitValue}"
    }
    val trackValue: BLESS_Types.flag = get_track().get
    if(!track(trackValue)) {
      testFailures = testFailures :+ st"'track' did not match expected: value of the outgoing data port is ${trackValue}"
    }
    val hyValue: PACE_Data.ms = get_hy().get
    if(!hy(hyValue)) {
      testFailures = testFailures :+ st"'hy' did not match expected: value of the outgoing data port is ${hyValue}"
    }
    val rrValue: BLESS_Types.flag = get_rr().get
    if(!rr(rrValue)) {
      testFailures = testFailures :+ st"'rr' did not match expected: value of the outgoing data port is ${rrValue}"
    }
    val rfValue: PACE_Data.rf = get_rf().get
    if(!rf(rfValue)) {
      testFailures = testFailures :+ st"'rf' did not match expected: value of the outgoing data port is ${rfValue}"
    }
    val msrValue: PACE_Data.ms = get_msr().get
    if(!msr(msrValue)) {
      testFailures = testFailures :+ st"'msr' did not match expected: value of the outgoing data port is ${msrValue}"
    }
    val min_avValue: PACE_Data.ms = get_min_av().get
    if(!min_av(min_avValue)) {
      testFailures = testFailures :+ st"'min_av' did not match expected: value of the outgoing data port is ${min_avValue}"
    }
    val ex_pvarpValue: PACE_Data.ms = get_ex_pvarp().get
    if(!ex_pvarp(ex_pvarpValue)) {
      testFailures = testFailures :+ st"'ex_pvarp' did not match expected: value of the outgoing data port is ${ex_pvarpValue}"
    }
    val rtValue: PACE_Data.second = get_rt().get
    if(!rt(rtValue)) {
      testFailures = testFailures :+ st"'rt' did not match expected: value of the outgoing data port is ${rtValue}"
    }
    val ctValue: PACE_Data.second = get_ct().get
    if(!ct(ctValue)) {
      testFailures = testFailures :+ st"'ct' did not match expected: value of the outgoing data port is ${ctValue}"
    }
    val atr_enableValue: BLESS_Types.flag = get_atr_enable().get
    if(!atr_enable(atr_enableValue)) {
      testFailures = testFailures :+ st"'atr_enable' did not match expected: value of the outgoing data port is ${atr_enableValue}"
    }
    val atr_durationValue: PACE_Data.CCcount = get_atr_duration().get
    if(!atr_duration(atr_durationValue)) {
      testFailures = testFailures :+ st"'atr_duration' did not match expected: value of the outgoing data port is ${atr_durationValue}"
    }
    val fb_timeValue: PACE_Data.second = get_fb_time().get
    if(!fb_time(fb_timeValue)) {
      testFailures = testFailures :+ st"'fb_time' did not match expected: value of the outgoing data port is ${fb_timeValue}"
    }
    val drsValue: PACE_Data.percent = get_drs().get
    if(!drs(drsValue)) {
      testFailures = testFailures :+ st"'drs' did not match expected: value of the outgoing data port is ${drsValue}"
    }
    val ursValue: PACE_Data.percent = get_urs().get
    if(!urs(ursValue)) {
      testFailures = testFailures :+ st"'urs' did not match expected: value of the outgoing data port is ${ursValue}"
    }

    assert(testFailures.isEmpty, st"${(testFailures, "\n")}".render)
  }


  // setter for in EventDataPort
  def put_settings(value : PACE_Data.Rx): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.operational_api.settings_Id, PACE_Data.Rx_Payload(value))
  }

  // getter for out DataPort
  def get_lrl(): Option[PACE_Data.ms] = {
    val value: Option[PACE_Data.ms] = get_lrl_payload() match {
      case Some(PACE_Data.ms_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port lrl.  Expecting 'PACE_Data.ms_Payload' but received ${v}")
      case _ => None[PACE_Data.ms]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_lrl_payload(): Option[PACE_Data.ms_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.lrl_Id).asInstanceOf[Option[PACE_Data.ms_Payload]]
  }

  // getter for out DataPort
  def get_url(): Option[PACE_Data.ms] = {
    val value: Option[PACE_Data.ms] = get_url_payload() match {
      case Some(PACE_Data.ms_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port url.  Expecting 'PACE_Data.ms_Payload' but received ${v}")
      case _ => None[PACE_Data.ms]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_url_payload(): Option[PACE_Data.ms_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.url_Id).asInstanceOf[Option[PACE_Data.ms_Payload]]
  }

  // getter for out DataPort
  def get_av(): Option[PACE_Data.ms] = {
    val value: Option[PACE_Data.ms] = get_av_payload() match {
      case Some(PACE_Data.ms_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port av.  Expecting 'PACE_Data.ms_Payload' but received ${v}")
      case _ => None[PACE_Data.ms]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_av_payload(): Option[PACE_Data.ms_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.av_Id).asInstanceOf[Option[PACE_Data.ms_Payload]]
  }

  // getter for out DataPort
  def get_savo(): Option[PACE_Data.ms] = {
    val value: Option[PACE_Data.ms] = get_savo_payload() match {
      case Some(PACE_Data.ms_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port savo.  Expecting 'PACE_Data.ms_Payload' but received ${v}")
      case _ => None[PACE_Data.ms]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_savo_payload(): Option[PACE_Data.ms_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.savo_Id).asInstanceOf[Option[PACE_Data.ms_Payload]]
  }

  // getter for out DataPort
  def get_act(): Option[PACE_Data.milliG] = {
    val value: Option[PACE_Data.milliG] = get_act_payload() match {
      case Some(PACE_Data.milliG_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port act.  Expecting 'PACE_Data.milliG_Payload' but received ${v}")
      case _ => None[PACE_Data.milliG]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_act_payload(): Option[PACE_Data.milliG_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.act_Id).asInstanceOf[Option[PACE_Data.milliG_Payload]]
  }

  // getter for out DataPort
  def get_vrp(): Option[PACE_Data.ms] = {
    val value: Option[PACE_Data.ms] = get_vrp_payload() match {
      case Some(PACE_Data.ms_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port vrp.  Expecting 'PACE_Data.ms_Payload' but received ${v}")
      case _ => None[PACE_Data.ms]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_vrp_payload(): Option[PACE_Data.ms_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.vrp_Id).asInstanceOf[Option[PACE_Data.ms_Payload]]
  }

  // getter for out DataPort
  def get_arp(): Option[PACE_Data.ms] = {
    val value: Option[PACE_Data.ms] = get_arp_payload() match {
      case Some(PACE_Data.ms_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port arp.  Expecting 'PACE_Data.ms_Payload' but received ${v}")
      case _ => None[PACE_Data.ms]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_arp_payload(): Option[PACE_Data.ms_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.arp_Id).asInstanceOf[Option[PACE_Data.ms_Payload]]
  }

  // getter for out DataPort
  def get_pvarp(): Option[PACE_Data.ms] = {
    val value: Option[PACE_Data.ms] = get_pvarp_payload() match {
      case Some(PACE_Data.ms_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port pvarp.  Expecting 'PACE_Data.ms_Payload' but received ${v}")
      case _ => None[PACE_Data.ms]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_pvarp_payload(): Option[PACE_Data.ms_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.pvarp_Id).asInstanceOf[Option[PACE_Data.ms_Payload]]
  }

  // getter for out DataPort
  def get_pv(): Option[BLESS_Types.flag] = {
    val value: Option[BLESS_Types.flag] = get_pv_payload() match {
      case Some(BLESS_Types.flag_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port pv.  Expecting 'BLESS_Types.flag_Payload' but received ${v}")
      case _ => None[BLESS_Types.flag]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_pv_payload(): Option[BLESS_Types.flag_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.pv_Id).asInstanceOf[Option[BLESS_Types.flag_Payload]]
  }

  // getter for out DataPort
  def get_sv(): Option[BLESS_Types.flag] = {
    val value: Option[BLESS_Types.flag] = get_sv_payload() match {
      case Some(BLESS_Types.flag_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port sv.  Expecting 'BLESS_Types.flag_Payload' but received ${v}")
      case _ => None[BLESS_Types.flag]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_sv_payload(): Option[BLESS_Types.flag_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.sv_Id).asInstanceOf[Option[BLESS_Types.flag_Payload]]
  }

  // getter for out DataPort
  def get_pa(): Option[BLESS_Types.flag] = {
    val value: Option[BLESS_Types.flag] = get_pa_payload() match {
      case Some(BLESS_Types.flag_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port pa.  Expecting 'BLESS_Types.flag_Payload' but received ${v}")
      case _ => None[BLESS_Types.flag]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_pa_payload(): Option[BLESS_Types.flag_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.pa_Id).asInstanceOf[Option[BLESS_Types.flag_Payload]]
  }

  // getter for out DataPort
  def get_sa(): Option[BLESS_Types.flag] = {
    val value: Option[BLESS_Types.flag] = get_sa_payload() match {
      case Some(BLESS_Types.flag_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port sa.  Expecting 'BLESS_Types.flag_Payload' but received ${v}")
      case _ => None[BLESS_Types.flag]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_sa_payload(): Option[BLESS_Types.flag_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.sa_Id).asInstanceOf[Option[BLESS_Types.flag_Payload]]
  }

  // getter for out DataPort
  def get_inhibit(): Option[BLESS_Types.flag] = {
    val value: Option[BLESS_Types.flag] = get_inhibit_payload() match {
      case Some(BLESS_Types.flag_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port inhibit.  Expecting 'BLESS_Types.flag_Payload' but received ${v}")
      case _ => None[BLESS_Types.flag]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_inhibit_payload(): Option[BLESS_Types.flag_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.inhibit_Id).asInstanceOf[Option[BLESS_Types.flag_Payload]]
  }

  // getter for out DataPort
  def get_track(): Option[BLESS_Types.flag] = {
    val value: Option[BLESS_Types.flag] = get_track_payload() match {
      case Some(BLESS_Types.flag_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port track.  Expecting 'BLESS_Types.flag_Payload' but received ${v}")
      case _ => None[BLESS_Types.flag]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_track_payload(): Option[BLESS_Types.flag_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.track_Id).asInstanceOf[Option[BLESS_Types.flag_Payload]]
  }

  // getter for out DataPort
  def get_hy(): Option[PACE_Data.ms] = {
    val value: Option[PACE_Data.ms] = get_hy_payload() match {
      case Some(PACE_Data.ms_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port hy.  Expecting 'PACE_Data.ms_Payload' but received ${v}")
      case _ => None[PACE_Data.ms]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_hy_payload(): Option[PACE_Data.ms_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.hy_Id).asInstanceOf[Option[PACE_Data.ms_Payload]]
  }

  // getter for out DataPort
  def get_rr(): Option[BLESS_Types.flag] = {
    val value: Option[BLESS_Types.flag] = get_rr_payload() match {
      case Some(BLESS_Types.flag_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port rr.  Expecting 'BLESS_Types.flag_Payload' but received ${v}")
      case _ => None[BLESS_Types.flag]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_rr_payload(): Option[BLESS_Types.flag_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.rr_Id).asInstanceOf[Option[BLESS_Types.flag_Payload]]
  }

  // getter for out DataPort
  def get_rf(): Option[PACE_Data.rf] = {
    val value: Option[PACE_Data.rf] = get_rf_payload() match {
      case Some(PACE_Data.rf_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port rf.  Expecting 'PACE_Data.rf_Payload' but received ${v}")
      case _ => None[PACE_Data.rf]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_rf_payload(): Option[PACE_Data.rf_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.rf_Id).asInstanceOf[Option[PACE_Data.rf_Payload]]
  }

  // getter for out DataPort
  def get_msr(): Option[PACE_Data.ms] = {
    val value: Option[PACE_Data.ms] = get_msr_payload() match {
      case Some(PACE_Data.ms_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port msr.  Expecting 'PACE_Data.ms_Payload' but received ${v}")
      case _ => None[PACE_Data.ms]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_msr_payload(): Option[PACE_Data.ms_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.msr_Id).asInstanceOf[Option[PACE_Data.ms_Payload]]
  }

  // getter for out DataPort
  def get_min_av(): Option[PACE_Data.ms] = {
    val value: Option[PACE_Data.ms] = get_min_av_payload() match {
      case Some(PACE_Data.ms_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port min_av.  Expecting 'PACE_Data.ms_Payload' but received ${v}")
      case _ => None[PACE_Data.ms]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_min_av_payload(): Option[PACE_Data.ms_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.min_av_Id).asInstanceOf[Option[PACE_Data.ms_Payload]]
  }

  // getter for out DataPort
  def get_ex_pvarp(): Option[PACE_Data.ms] = {
    val value: Option[PACE_Data.ms] = get_ex_pvarp_payload() match {
      case Some(PACE_Data.ms_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port ex_pvarp.  Expecting 'PACE_Data.ms_Payload' but received ${v}")
      case _ => None[PACE_Data.ms]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_ex_pvarp_payload(): Option[PACE_Data.ms_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.ex_pvarp_Id).asInstanceOf[Option[PACE_Data.ms_Payload]]
  }

  // getter for out DataPort
  def get_rt(): Option[PACE_Data.second] = {
    val value: Option[PACE_Data.second] = get_rt_payload() match {
      case Some(PACE_Data.second_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port rt.  Expecting 'PACE_Data.second_Payload' but received ${v}")
      case _ => None[PACE_Data.second]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_rt_payload(): Option[PACE_Data.second_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.rt_Id).asInstanceOf[Option[PACE_Data.second_Payload]]
  }

  // getter for out DataPort
  def get_ct(): Option[PACE_Data.second] = {
    val value: Option[PACE_Data.second] = get_ct_payload() match {
      case Some(PACE_Data.second_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port ct.  Expecting 'PACE_Data.second_Payload' but received ${v}")
      case _ => None[PACE_Data.second]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_ct_payload(): Option[PACE_Data.second_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.ct_Id).asInstanceOf[Option[PACE_Data.second_Payload]]
  }

  // getter for out DataPort
  def get_atr_enable(): Option[BLESS_Types.flag] = {
    val value: Option[BLESS_Types.flag] = get_atr_enable_payload() match {
      case Some(BLESS_Types.flag_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port atr_enable.  Expecting 'BLESS_Types.flag_Payload' but received ${v}")
      case _ => None[BLESS_Types.flag]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_atr_enable_payload(): Option[BLESS_Types.flag_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.atr_enable_Id).asInstanceOf[Option[BLESS_Types.flag_Payload]]
  }

  // getter for out DataPort
  def get_atr_duration(): Option[PACE_Data.CCcount] = {
    val value: Option[PACE_Data.CCcount] = get_atr_duration_payload() match {
      case Some(PACE_Data.CCcount_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port atr_duration.  Expecting 'PACE_Data.CCcount_Payload' but received ${v}")
      case _ => None[PACE_Data.CCcount]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_atr_duration_payload(): Option[PACE_Data.CCcount_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.atr_duration_Id).asInstanceOf[Option[PACE_Data.CCcount_Payload]]
  }

  // getter for out DataPort
  def get_fb_time(): Option[PACE_Data.second] = {
    val value: Option[PACE_Data.second] = get_fb_time_payload() match {
      case Some(PACE_Data.second_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port fb_time.  Expecting 'PACE_Data.second_Payload' but received ${v}")
      case _ => None[PACE_Data.second]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_fb_time_payload(): Option[PACE_Data.second_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.fb_time_Id).asInstanceOf[Option[PACE_Data.second_Payload]]
  }

  // getter for out DataPort
  def get_drs(): Option[PACE_Data.percent] = {
    val value: Option[PACE_Data.percent] = get_drs_payload() match {
      case Some(PACE_Data.percent_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port drs.  Expecting 'PACE_Data.percent_Payload' but received ${v}")
      case _ => None[PACE_Data.percent]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_drs_payload(): Option[PACE_Data.percent_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.drs_Id).asInstanceOf[Option[PACE_Data.percent_Payload]]
  }

  // getter for out DataPort
  def get_urs(): Option[PACE_Data.percent] = {
    val value: Option[PACE_Data.percent] = get_urs_payload() match {
      case Some(PACE_Data.percent_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port urs.  Expecting 'PACE_Data.percent_Payload' but received ${v}")
      case _ => None[PACE_Data.percent]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_urs_payload(): Option[PACE_Data.percent_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_stg.initialization_api.urs_Id).asInstanceOf[Option[PACE_Data.percent_Payload]]
  }

}
