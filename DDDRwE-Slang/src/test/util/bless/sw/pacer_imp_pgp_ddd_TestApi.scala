// #Sireum

package bless.sw

import org.sireum._
import art.{Art, ArtNative, Empty}
import bless._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun
@msig trait pacer_imp_pgp_ddd_TestApi {

  def BeforeEntrypoint(): Unit = {
    Art.initTest(Arch.PG_imp_Instance_pgp_ddd)
  }

  def AfterEntrypoint(): Unit = {
    Art.finalizeTest(Arch.PG_imp_Instance_pgp_ddd)
  }

  def testCompute(): Unit = {
    Art.manuallyClearOutput()
    Art.testCompute(Arch.PG_imp_Instance_pgp_ddd)
  }

  def testInitialise(): Unit = {
    Art.manuallyClearOutput()
    Art.testInitialise(Arch.PG_imp_Instance_pgp_ddd)
  }

  /** helper function to set the values of all input ports.
   * @param tna payload for data port tna
   * @param tnv payload for data port tnv
   * @param min_cci payload for data port min_cci
   * @param max_cci payload for data port max_cci
   * @param atr_max_cci payload for data port atr_max_cci
   * @param dav payload for data port dav
   * @param fb payload for data port fb
   * @param lrl payload for data port lrl
   * @param url payload for data port url
   * @param av payload for data port av
   * @param savo payload for data port savo
   * @param act payload for data port act
   * @param vrp payload for data port vrp
   * @param arp payload for data port arp
   * @param pvarp payload for data port pvarp
   * @param ex_pvarp payload for data port ex_pvarp
   * @param hy payload for data port hy
   * @param min_av payload for data port min_av
   * @param pv payload for data port pv
   * @param sv payload for data port sv
   * @param pa payload for data port pa
   * @param sa payload for data port sa
   * @param inhibit payload for data port inhibit
   * @param track payload for data port track
   * @param a the number of events to place in the a event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param v the number of events to place in the v event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   */
  def put_concrete_inputs(tna : BLESS_Types.flag,
                          tnv : BLESS_Types.flag,
                          min_cci : PACE_Data.ms,
                          max_cci : PACE_Data.ms,
                          atr_max_cci : PACE_Data.ms,
                          dav : PACE_Data.ms,
                          fb : BLESS_Types.flag,
                          lrl : PACE_Data.ms,
                          url : PACE_Data.ms,
                          av : PACE_Data.ms,
                          savo : PACE_Data.ms,
                          act : PACE_Data.milliG,
                          vrp : PACE_Data.ms,
                          arp : PACE_Data.ms,
                          pvarp : PACE_Data.ms,
                          ex_pvarp : PACE_Data.ms,
                          hy : PACE_Data.ms,
                          min_av : PACE_Data.ms,
                          pv : BLESS_Types.flag,
                          sv : BLESS_Types.flag,
                          pa : BLESS_Types.flag,
                          sa : BLESS_Types.flag,
                          inhibit : BLESS_Types.flag,
                          track : BLESS_Types.flag,
                          a : Z,
                          v : Z): Unit = {
    put_tna(tna)
    put_tnv(tnv)
    put_min_cci(min_cci)
    put_max_cci(max_cci)
    put_atr_max_cci(atr_max_cci)
    put_dav(dav)
    put_fb(fb)
    put_lrl(lrl)
    put_url(url)
    put_av(av)
    put_savo(savo)
    put_act(act)
    put_vrp(vrp)
    put_arp(arp)
    put_pvarp(pvarp)
    put_ex_pvarp(ex_pvarp)
    put_hy(hy)
    put_min_av(min_av)
    put_pv(pv)
    put_sv(sv)
    put_pa(pa)
    put_sa(sa)
    put_inhibit(inhibit)
    put_track(track)
    for(i <- 0 until a) {
      put_a()
    }
    for(i <- 0 until v) {
      put_v()
    }
  }


  /** helper function to check pacer_imp_pgp_ddd's
   * output ports.  Use named arguments to check subsets of the output ports.
   * @param last_v_was_vs method that will be called with the value of the outgoing data
   *        port 'last_v_was_vs'.
   * @param cci method that will be called with the payloads to be sent
   *        on the outgoing event data port 'cci'.
   * @param ap method that will be called with the number of events to be sent
   *        on the outgoing event port 'ap'.
   * @param vp method that will be called with the number of events to be sent
   *        on the outgoing event port 'vp'.
   * @param as method that will be called with the number of events to be sent
   *        on the outgoing event port 'as'.
   * @param at method that will be called with the number of events to be sent
   *        on the outgoing event port 'at'.
   * @param vs method that will be called with the number of events to be sent
   *        on the outgoing event port 'vs'.
   * @param pvc method that will be called with the number of events to be sent
   *        on the outgoing event port 'pvc'.
   * @param ras method that will be called with the number of events to be sent
   *        on the outgoing event port 'ras'.
   * @param rvs method that will be called with the number of events to be sent
   *        on the outgoing event port 'rvs'.
   */
  def check_concrete_output(last_v_was_vs: BLESS_Types.flag => B,
                            cci: ISZ[PACE_Data.ms] => B,
                            ap: Z => B,
                            vp: Z => B,
                            as: Z => B,
                            at: Z => B,
                            vs: Z => B,
                            pvc: Z => B,
                            ras: Z => B,
                            rvs: Z => B): Unit = {
    var testFailures: ISZ[ST] = ISZ()

    val last_v_was_vsValue: BLESS_Types.flag = get_last_v_was_vs().get
    if(!last_v_was_vs(last_v_was_vsValue)) {
      testFailures = testFailures :+ st"'last_v_was_vs' did not match expected: value of the outgoing data port is ${last_v_was_vsValue}"
    }
    var cciValue: ISZ[PACE_Data.ms] = ISZ()
    // TODO: event data port getter should return all of the events/payloads
    //       received on event data ports when queue sizes > 1 support is added
    //       to ART
    if(get_cci().nonEmpty) { cciValue = cciValue :+ get_cci().get }
    if(!cci(cciValue)) {
      testFailures = testFailures :+ st"'cci' did not match expected: received ${cciValue.size} events with the following payloads ${cciValue}"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val apValue: Z = if(get_ap().nonEmpty) z"1" else z"0"
    if(!ap(apValue)) {
      testFailures = testFailures :+ st"'ap' did not match expected: ${apValue} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val vpValue: Z = if(get_vp().nonEmpty) z"1" else z"0"
    if(!vp(vpValue)) {
      testFailures = testFailures :+ st"'vp' did not match expected: ${vpValue} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val asValue: Z = if(get_as().nonEmpty) z"1" else z"0"
    if(!as(asValue)) {
      testFailures = testFailures :+ st"'as' did not match expected: ${asValue} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val atValue: Z = if(get_at().nonEmpty) z"1" else z"0"
    if(!at(atValue)) {
      testFailures = testFailures :+ st"'at' did not match expected: ${atValue} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val vsValue: Z = if(get_vs().nonEmpty) z"1" else z"0"
    if(!vs(vsValue)) {
      testFailures = testFailures :+ st"'vs' did not match expected: ${vsValue} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val pvcValue: Z = if(get_pvc().nonEmpty) z"1" else z"0"
    if(!pvc(pvcValue)) {
      testFailures = testFailures :+ st"'pvc' did not match expected: ${pvcValue} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val rasValue: Z = if(get_ras().nonEmpty) z"1" else z"0"
    if(!ras(rasValue)) {
      testFailures = testFailures :+ st"'ras' did not match expected: ${rasValue} events were in the outgoing event queue"
    }
    // TODO: event port getter should return the number of events in
    //       the output queue when queue sizes > 1 support is added to ART
    val rvsValue: Z = if(get_rvs().nonEmpty) z"1" else z"0"
    if(!rvs(rvsValue)) {
      testFailures = testFailures :+ st"'rvs' did not match expected: ${rvsValue} events were in the outgoing event queue"
    }

    assert(testFailures.isEmpty, st"${(testFailures, "\n")}".render)
  }


  // setter for in DataPort
  def put_tna(value : BLESS_Types.flag): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.tna_Id, BLESS_Types.flag_Payload(value))
  }

  // setter for in DataPort
  def put_tnv(value : BLESS_Types.flag): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.tnv_Id, BLESS_Types.flag_Payload(value))
  }

  // setter for in DataPort
  def put_min_cci(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.min_cci_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_max_cci(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.max_cci_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_atr_max_cci(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.atr_max_cci_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_dav(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.dav_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_fb(value : BLESS_Types.flag): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.fb_Id, BLESS_Types.flag_Payload(value))
  }

  // setter for in DataPort
  def put_lrl(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.lrl_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_url(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.url_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_av(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.av_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_savo(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.savo_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_act(value : PACE_Data.milliG): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.act_Id, PACE_Data.milliG_Payload(value))
  }

  // setter for in DataPort
  def put_vrp(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.vrp_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_arp(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.arp_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_pvarp(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.pvarp_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_ex_pvarp(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.ex_pvarp_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_hy(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.hy_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_min_av(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.min_av_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_pv(value : BLESS_Types.flag): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.pv_Id, BLESS_Types.flag_Payload(value))
  }

  // setter for in DataPort
  def put_sv(value : BLESS_Types.flag): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.sv_Id, BLESS_Types.flag_Payload(value))
  }

  // setter for in DataPort
  def put_pa(value : BLESS_Types.flag): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.pa_Id, BLESS_Types.flag_Payload(value))
  }

  // setter for in DataPort
  def put_sa(value : BLESS_Types.flag): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.sa_Id, BLESS_Types.flag_Payload(value))
  }

  // setter for in DataPort
  def put_inhibit(value : BLESS_Types.flag): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.inhibit_Id, BLESS_Types.flag_Payload(value))
  }

  // setter for in DataPort
  def put_track(value : BLESS_Types.flag): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.track_Id, BLESS_Types.flag_Payload(value))
  }

  // setter for in EventPort
  def put_a(): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.a_Id, Empty())
  }

  // setter for in EventPort
  def put_v(): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.operational_api.v_Id, Empty())
  }

  // getter for out DataPort
  def get_last_v_was_vs(): Option[BLESS_Types.flag] = {
    val value: Option[BLESS_Types.flag] = get_last_v_was_vs_payload() match {
      case Some(BLESS_Types.flag_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port last_v_was_vs.  Expecting 'BLESS_Types.flag_Payload' but received ${v}")
      case _ => None[BLESS_Types.flag]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_last_v_was_vs_payload(): Option[BLESS_Types.flag_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.initialization_api.last_v_was_vs_Id).asInstanceOf[Option[BLESS_Types.flag_Payload]]
  }

  // getter for out EventDataPort
  def get_cci(): Option[PACE_Data.ms] = {
    val value: Option[PACE_Data.ms] = get_cci_payload() match {
      case Some(PACE_Data.ms_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port cci.  Expecting 'PACE_Data.ms_Payload' but received ${v}")
      case _ => None[PACE_Data.ms]()
    }
    return value
  }

  // payload getter for out EventDataPort
  def get_cci_payload(): Option[PACE_Data.ms_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.initialization_api.cci_Id).asInstanceOf[Option[PACE_Data.ms_Payload]]
  }

  // getter for out EventPort
  def get_ap(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_ap_payload() match {
      case Some(Empty()) => Some(Empty())
      case Some(v) => halt(s"Unexpected payload on port ap.  Expecting 'Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_ap_payload(): Option[Empty] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.initialization_api.ap_Id).asInstanceOf[Option[Empty]]
  }

  // getter for out EventPort
  def get_vp(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_vp_payload() match {
      case Some(Empty()) => Some(Empty())
      case Some(v) => halt(s"Unexpected payload on port vp.  Expecting 'Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_vp_payload(): Option[Empty] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.initialization_api.vp_Id).asInstanceOf[Option[Empty]]
  }

  // getter for out EventPort
  def get_as(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_as_payload() match {
      case Some(Empty()) => Some(Empty())
      case Some(v) => halt(s"Unexpected payload on port as.  Expecting 'Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_as_payload(): Option[Empty] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.initialization_api.as_Id).asInstanceOf[Option[Empty]]
  }

  // getter for out EventPort
  def get_at(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_at_payload() match {
      case Some(Empty()) => Some(Empty())
      case Some(v) => halt(s"Unexpected payload on port at.  Expecting 'Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_at_payload(): Option[Empty] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.initialization_api.at_Id).asInstanceOf[Option[Empty]]
  }

  // getter for out EventPort
  def get_vs(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_vs_payload() match {
      case Some(Empty()) => Some(Empty())
      case Some(v) => halt(s"Unexpected payload on port vs.  Expecting 'Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_vs_payload(): Option[Empty] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.initialization_api.vs_Id).asInstanceOf[Option[Empty]]
  }

  // getter for out EventPort
  def get_pvc(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_pvc_payload() match {
      case Some(Empty()) => Some(Empty())
      case Some(v) => halt(s"Unexpected payload on port pvc.  Expecting 'Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_pvc_payload(): Option[Empty] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.initialization_api.pvc_Id).asInstanceOf[Option[Empty]]
  }

  // getter for out EventPort
  def get_ras(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_ras_payload() match {
      case Some(Empty()) => Some(Empty())
      case Some(v) => halt(s"Unexpected payload on port ras.  Expecting 'Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_ras_payload(): Option[Empty] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.initialization_api.ras_Id).asInstanceOf[Option[Empty]]
  }

  // getter for out EventPort
  def get_rvs(): Option[art.Empty] = {
    val value: Option[art.Empty] = get_rvs_payload() match {
      case Some(Empty()) => Some(Empty())
      case Some(v) => halt(s"Unexpected payload on port rvs.  Expecting 'Empty' but received ${v}")
      case _ => None[art.Empty]()
    }
    return value
  }

  // payload getter for out EventPort
  def get_rvs_payload(): Option[Empty] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_ddd.initialization_api.rvs_Id).asInstanceOf[Option[Empty]]
  }

}
