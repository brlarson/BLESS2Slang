// #Sireum

package bless.mark

import org.sireum._
import art.{Art, ArtNative, Empty}
import bless._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun
@msig trait Markers_imp_pgp_mkr_TestApi {

  def BeforeEntrypoint(): Unit = {
    Art.initTest(Arch.PG_imp_Instance_pgp_mkr)
  }

  def AfterEntrypoint(): Unit = {
    Art.finalizeTest(Arch.PG_imp_Instance_pgp_mkr)
  }

  def testCompute(): Unit = {
    Art.manuallyClearOutput()
    Art.testCompute(Arch.PG_imp_Instance_pgp_mkr)
  }

  def testInitialise(): Unit = {
    Art.manuallyClearOutput()
    Art.testInitialise(Arch.PG_imp_Instance_pgp_mkr)
  }

  /** helper function to set the values of all input ports.
   * @param tna payload for data port tna
   * @param tnv payload for data port tnv
   * @param cci payload for data port cci
   * @param atr_dct payloads for event data port atr_dct.
   *   ART currently supports single element event data queues so
   *   only the last element of atr_dct will be used
   * @param atr_end payloads for event data port atr_end.
   *   ART currently supports single element event data queues so
   *   only the last element of atr_end will be used
   * @param ap the number of events to place in the ap event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param vp the number of events to place in the vp event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param as the number of events to place in the as event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param at the number of events to place in the at event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param vs the number of events to place in the vs event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param pvc the number of events to place in the pvc event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param ras the number of events to place in the ras event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param rvs the number of events to place in the rvs event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   * @param atr_fb the number of events to place in the atr_fb event port queue.
   *   ART currently supports single element event queues so at most
   *   one event will be placed in the queue.
   */
  def put_concrete_inputs(tna : BLESS_Types.flag,
                          tnv : BLESS_Types.flag,
                          cci : PACE_Data.ms,
                          atr_dct : ISZ[BLESS_Types.flag],
                          atr_end : ISZ[BLESS_Types.flag],
                          ap : Z,
                          vp : Z,
                          as : Z,
                          at : Z,
                          vs : Z,
                          pvc : Z,
                          ras : Z,
                          rvs : Z,
                          atr_fb : Z): Unit = {
    put_tna(tna)
    put_tnv(tnv)
    put_cci(cci)
    for(v <- atr_dct){
      put_atr_dct(v)
    }
    for(v <- atr_end){
      put_atr_end(v)
    }
    for(i <- 0 until ap) {
      put_ap()
    }
    for(i <- 0 until vp) {
      put_vp()
    }
    for(i <- 0 until as) {
      put_as()
    }
    for(i <- 0 until at) {
      put_at()
    }
    for(i <- 0 until vs) {
      put_vs()
    }
    for(i <- 0 until pvc) {
      put_pvc()
    }
    for(i <- 0 until ras) {
      put_ras()
    }
    for(i <- 0 until rvs) {
      put_rvs()
    }
    for(i <- 0 until atr_fb) {
      put_atr_fb()
    }
  }


  /** helper function to check Markers_imp_pgp_mkr's
   * output ports.  Use named arguments to check subsets of the output ports.
   * @param mark_A method that will be called with the payloads to be sent
   *        on the outgoing event data port 'mark_A'.
   * @param mark_V method that will be called with the payloads to be sent
   *        on the outgoing event data port 'mark_V'.
   * @param mark_X method that will be called with the payloads to be sent
   *        on the outgoing event data port 'mark_X'.
   */
  def check_concrete_output(mark_A: ISZ[mark.AtrialMarker] => B,
                            mark_V: ISZ[mark.VentricularlMarker] => B,
                            mark_X: ISZ[mark.ExtraordinaryMarker] => B): Unit = {
    var testFailures: ISZ[ST] = ISZ()

    var mark_AValue: ISZ[mark.AtrialMarker] = ISZ()
    // TODO: event data port getter should return all of the events/payloads
    //       received on event data ports when queue sizes > 1 support is added
    //       to ART
    if(get_mark_A().nonEmpty) { mark_AValue = mark_AValue :+ get_mark_A().get }
    if(!mark_A(mark_AValue)) {
      testFailures = testFailures :+ st"'mark_A' did not match expected: received ${mark_AValue.size} events with the following payloads ${mark_AValue}"
    }
    var mark_VValue: ISZ[mark.VentricularlMarker] = ISZ()
    // TODO: event data port getter should return all of the events/payloads
    //       received on event data ports when queue sizes > 1 support is added
    //       to ART
    if(get_mark_V().nonEmpty) { mark_VValue = mark_VValue :+ get_mark_V().get }
    if(!mark_V(mark_VValue)) {
      testFailures = testFailures :+ st"'mark_V' did not match expected: received ${mark_VValue.size} events with the following payloads ${mark_VValue}"
    }
    var mark_XValue: ISZ[mark.ExtraordinaryMarker] = ISZ()
    // TODO: event data port getter should return all of the events/payloads
    //       received on event data ports when queue sizes > 1 support is added
    //       to ART
    if(get_mark_X().nonEmpty) { mark_XValue = mark_XValue :+ get_mark_X().get }
    if(!mark_X(mark_XValue)) {
      testFailures = testFailures :+ st"'mark_X' did not match expected: received ${mark_XValue.size} events with the following payloads ${mark_XValue}"
    }

    assert(testFailures.isEmpty, st"${(testFailures, "\n")}".render)
  }


  // setter for in DataPort
  def put_tna(value : BLESS_Types.flag): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.operational_api.tna_Id, BLESS_Types.flag_Payload(value))
  }

  // setter for in DataPort
  def put_tnv(value : BLESS_Types.flag): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.operational_api.tnv_Id, BLESS_Types.flag_Payload(value))
  }

  // setter for in DataPort
  def put_cci(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.operational_api.cci_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in EventDataPort
  def put_atr_dct(value : BLESS_Types.flag): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.operational_api.atr_dct_Id, BLESS_Types.flag_Payload(value))
  }

  // setter for in EventDataPort
  def put_atr_end(value : BLESS_Types.flag): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.operational_api.atr_end_Id, BLESS_Types.flag_Payload(value))
  }

  // setter for in EventPort
  def put_ap(): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.operational_api.ap_Id, Empty())
  }

  // setter for in EventPort
  def put_vp(): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.operational_api.vp_Id, Empty())
  }

  // setter for in EventPort
  def put_as(): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.operational_api.as_Id, Empty())
  }

  // setter for in EventPort
  def put_at(): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.operational_api.at_Id, Empty())
  }

  // setter for in EventPort
  def put_vs(): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.operational_api.vs_Id, Empty())
  }

  // setter for in EventPort
  def put_pvc(): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.operational_api.pvc_Id, Empty())
  }

  // setter for in EventPort
  def put_ras(): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.operational_api.ras_Id, Empty())
  }

  // setter for in EventPort
  def put_rvs(): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.operational_api.rvs_Id, Empty())
  }

  // setter for in EventPort
  def put_atr_fb(): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.operational_api.atr_fb_Id, Empty())
  }

  // getter for out EventDataPort
  def get_mark_A(): Option[mark.AtrialMarker] = {
    val value: Option[mark.AtrialMarker] = get_mark_A_payload() match {
      case Some(mark.AtrialMarker_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port mark_A.  Expecting 'mark.AtrialMarker_Payload' but received ${v}")
      case _ => None[mark.AtrialMarker]()
    }
    return value
  }

  // payload getter for out EventDataPort
  def get_mark_A_payload(): Option[mark.AtrialMarker_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.initialization_api.mark_A_Id).asInstanceOf[Option[mark.AtrialMarker_Payload]]
  }

  // getter for out EventDataPort
  def get_mark_V(): Option[mark.VentricularlMarker] = {
    val value: Option[mark.VentricularlMarker] = get_mark_V_payload() match {
      case Some(mark.VentricularlMarker_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port mark_V.  Expecting 'mark.VentricularlMarker_Payload' but received ${v}")
      case _ => None[mark.VentricularlMarker]()
    }
    return value
  }

  // payload getter for out EventDataPort
  def get_mark_V_payload(): Option[mark.VentricularlMarker_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.initialization_api.mark_V_Id).asInstanceOf[Option[mark.VentricularlMarker_Payload]]
  }

  // getter for out EventDataPort
  def get_mark_X(): Option[mark.ExtraordinaryMarker] = {
    val value: Option[mark.ExtraordinaryMarker] = get_mark_X_payload() match {
      case Some(mark.ExtraordinaryMarker_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port mark_X.  Expecting 'mark.ExtraordinaryMarker_Payload' but received ${v}")
      case _ => None[mark.ExtraordinaryMarker]()
    }
    return value
  }

  // payload getter for out EventDataPort
  def get_mark_X_payload(): Option[mark.ExtraordinaryMarker_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_mkr.initialization_api.mark_X_Id).asInstanceOf[Option[mark.ExtraordinaryMarker_Payload]]
  }

}
