// #Sireum

package bless.rc

import org.sireum._
import art.{Art, ArtNative, Empty}
import bless._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun
@msig trait RateController_normal_pgp_rc_TestApi {

  def BeforeEntrypoint(): Unit = {
    Art.initTest(Arch.PG_imp_Instance_pgp_rc)
  }

  def AfterEntrypoint(): Unit = {
    Art.finalizeTest(Arch.PG_imp_Instance_pgp_rc)
  }

  def testCompute(): Unit = {
    Art.manuallyClearOutput()
    Art.testCompute(Arch.PG_imp_Instance_pgp_rc)
  }

  def testInitialise(): Unit = {
    Art.manuallyClearOutput()
    Art.testInitialise(Arch.PG_imp_Instance_pgp_rc)
  }

  /** helper function to set the values of all input ports.
   * @param xl payload for data port xl
   * @param mag payload for data port mag
   * @param last_v_was_vs payload for data port last_v_was_vs
   * @param rr payload for data port rr
   * @param rf payload for data port rf
   * @param rt payload for data port rt
   * @param at payload for data port at
   * @param ct payload for data port ct
   * @param lrl payload for data port lrl
   * @param url payload for data port url
   * @param msr payload for data port msr
   * @param av payload for data port av
   * @param min_av payload for data port min_av
   * @param drs payload for data port drs
   * @param urs payload for data port urs
   * @param fb_time payload for data port fb_time
   * @param hy payload for data port hy
   * @param cci payloads for event data port cci.
   *   ART currently supports single element event data queues so
   *   only the last element of cci will be used
   */
  def put_concrete_inputs(xl : PACE_Data.milliG,
                          mag : BLESS_Types.flag,
                          last_v_was_vs : BLESS_Types.flag,
                          rr : BLESS_Types.flag,
                          rf : PACE_Data.rf,
                          rt : PACE_Data.second,
                          at : PACE_Data.milliG,
                          ct : PACE_Data.second,
                          lrl : PACE_Data.ms,
                          url : PACE_Data.ms,
                          msr : PACE_Data.ms,
                          av : PACE_Data.ms,
                          min_av : PACE_Data.ms,
                          drs : PACE_Data.percent,
                          urs : PACE_Data.percent,
                          fb_time : PACE_Data.second,
                          hy : PACE_Data.ms,
                          cci : ISZ[PACE_Data.ms]): Unit = {
    put_xl(xl)
    put_mag(mag)
    put_last_v_was_vs(last_v_was_vs)
    put_rr(rr)
    put_rf(rf)
    put_rt(rt)
    put_at(at)
    put_ct(ct)
    put_lrl(lrl)
    put_url(url)
    put_msr(msr)
    put_av(av)
    put_min_av(min_av)
    put_drs(drs)
    put_urs(urs)
    put_fb_time(fb_time)
    put_hy(hy)
    for(v <- cci){
      put_cci(v)
    }
  }


  /** helper function to check RateController_normal_pgp_rc's
   * output ports.  Use named arguments to check subsets of the output ports.
   * @param min_cci method that will be called with the value of the outgoing data
   *        port 'min_cci'.
   * @param max_cci method that will be called with the value of the outgoing data
   *        port 'max_cci'.
   * @param atr_max_cci method that will be called with the value of the outgoing data
   *        port 'atr_max_cci'.
   * @param dav method that will be called with the value of the outgoing data
   *        port 'dav'.
   */
  def check_concrete_output(min_cci: PACE_Data.ms => B,
                            max_cci: PACE_Data.ms => B,
                            atr_max_cci: PACE_Data.ms => B,
                            dav: PACE_Data.ms => B): Unit = {
    var testFailures: ISZ[ST] = ISZ()

    val min_cciValue: PACE_Data.ms = get_min_cci().get
    if(!min_cci(min_cciValue)) {
      testFailures = testFailures :+ st"'min_cci' did not match expected: value of the outgoing data port is ${min_cciValue}"
    }
    val max_cciValue: PACE_Data.ms = get_max_cci().get
    if(!max_cci(max_cciValue)) {
      testFailures = testFailures :+ st"'max_cci' did not match expected: value of the outgoing data port is ${max_cciValue}"
    }
    val atr_max_cciValue: PACE_Data.ms = get_atr_max_cci().get
    if(!atr_max_cci(atr_max_cciValue)) {
      testFailures = testFailures :+ st"'atr_max_cci' did not match expected: value of the outgoing data port is ${atr_max_cciValue}"
    }
    val davValue: PACE_Data.ms = get_dav().get
    if(!dav(davValue)) {
      testFailures = testFailures :+ st"'dav' did not match expected: value of the outgoing data port is ${davValue}"
    }

    assert(testFailures.isEmpty, st"${(testFailures, "\n")}".render)
  }


  // setter for in DataPort
  def put_xl(value : PACE_Data.milliG): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.xl_Id, PACE_Data.milliG_Payload(value))
  }

  // setter for in DataPort
  def put_mag(value : BLESS_Types.flag): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.mag_Id, BLESS_Types.flag_Payload(value))
  }

  // setter for in DataPort
  def put_last_v_was_vs(value : BLESS_Types.flag): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.last_v_was_vs_Id, BLESS_Types.flag_Payload(value))
  }

  // setter for in DataPort
  def put_rr(value : BLESS_Types.flag): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.rr_Id, BLESS_Types.flag_Payload(value))
  }

  // setter for in DataPort
  def put_rf(value : PACE_Data.rf): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.rf_Id, PACE_Data.rf_Payload(value))
  }

  // setter for in DataPort
  def put_rt(value : PACE_Data.second): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.rt_Id, PACE_Data.second_Payload(value))
  }

  // setter for in DataPort
  def put_at(value : PACE_Data.milliG): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.at_Id, PACE_Data.milliG_Payload(value))
  }

  // setter for in DataPort
  def put_ct(value : PACE_Data.second): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.ct_Id, PACE_Data.second_Payload(value))
  }

  // setter for in DataPort
  def put_lrl(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.lrl_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_url(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.url_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_msr(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.msr_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_av(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.av_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_min_av(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.min_av_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in DataPort
  def put_drs(value : PACE_Data.percent): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.drs_Id, PACE_Data.percent_Payload(value))
  }

  // setter for in DataPort
  def put_urs(value : PACE_Data.percent): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.urs_Id, PACE_Data.percent_Payload(value))
  }

  // setter for in DataPort
  def put_fb_time(value : PACE_Data.second): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.fb_time_Id, PACE_Data.second_Payload(value))
  }

  // setter for in DataPort
  def put_hy(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.hy_Id, PACE_Data.ms_Payload(value))
  }

  // setter for in EventDataPort
  def put_cci(value : PACE_Data.ms): Unit = {
    ArtNative.insertInInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.operational_api.cci_Id, PACE_Data.ms_Payload(value))
  }

  // getter for out DataPort
  def get_min_cci(): Option[PACE_Data.ms] = {
    val value: Option[PACE_Data.ms] = get_min_cci_payload() match {
      case Some(PACE_Data.ms_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port min_cci.  Expecting 'PACE_Data.ms_Payload' but received ${v}")
      case _ => None[PACE_Data.ms]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_min_cci_payload(): Option[PACE_Data.ms_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.initialization_api.min_cci_Id).asInstanceOf[Option[PACE_Data.ms_Payload]]
  }

  // getter for out DataPort
  def get_max_cci(): Option[PACE_Data.ms] = {
    val value: Option[PACE_Data.ms] = get_max_cci_payload() match {
      case Some(PACE_Data.ms_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port max_cci.  Expecting 'PACE_Data.ms_Payload' but received ${v}")
      case _ => None[PACE_Data.ms]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_max_cci_payload(): Option[PACE_Data.ms_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.initialization_api.max_cci_Id).asInstanceOf[Option[PACE_Data.ms_Payload]]
  }

  // getter for out DataPort
  def get_atr_max_cci(): Option[PACE_Data.ms] = {
    val value: Option[PACE_Data.ms] = get_atr_max_cci_payload() match {
      case Some(PACE_Data.ms_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port atr_max_cci.  Expecting 'PACE_Data.ms_Payload' but received ${v}")
      case _ => None[PACE_Data.ms]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_atr_max_cci_payload(): Option[PACE_Data.ms_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.initialization_api.atr_max_cci_Id).asInstanceOf[Option[PACE_Data.ms_Payload]]
  }

  // getter for out DataPort
  def get_dav(): Option[PACE_Data.ms] = {
    val value: Option[PACE_Data.ms] = get_dav_payload() match {
      case Some(PACE_Data.ms_Payload(v)) => Some(v)
      case Some(v) => halt(s"Unexpected payload on port dav.  Expecting 'PACE_Data.ms_Payload' but received ${v}")
      case _ => None[PACE_Data.ms]()
    }
    return value
  }

  // payload getter for out DataPort
  def get_dav_payload(): Option[PACE_Data.ms_Payload] = {
    return ArtNative.observeOutInfrastructurePort(Arch.PG_imp_Instance_pgp_rc.initialization_api.dav_Id).asInstanceOf[Option[PACE_Data.ms_Payload]]
  }

}
