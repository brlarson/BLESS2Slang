// #Sireum

package bless.runtimemonitor

import org.sireum._
import bless._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

object GumboXDispatcher {
  def checkContract(observationKind: ObservationKind.Type, preContainer: Option[art.DataContent], postContainer: Option[art.DataContent]): B = {
    observationKind match {
      case bless.runtimemonitor.ObservationKind.PG_i_Instance_pp_t_postInit =>
        // checking the post-state values of t's initialise entrypoint is not required
        return T
      case bless.runtimemonitor.ObservationKind.PG_i_Instance_pp_t_preCompute =>
        // checking the pre-state values of t's compute entrypoint is not required
        return T
      case bless.runtimemonitor.ObservationKind.PG_i_Instance_pp_t_postCompute =>
        // checking the post-state values of t's compute entrypoint is not required
        return T

      case bless.runtimemonitor.ObservationKind.PG_i_Instance_pp_rc_postInit =>
        // checking the post-state values of rc's initialise entrypoint is not required
        return T
      case bless.runtimemonitor.ObservationKind.PG_i_Instance_pp_rc_preCompute =>
        // checking the pre-state values of rc's compute entrypoint is not required
        return T
      case bless.runtimemonitor.ObservationKind.PG_i_Instance_pp_rc_postCompute =>
        // checking the post-state values of rc's compute entrypoint is not required
        return T

      case _ => halt("Infeasible")
    }
  }

  def genTestSuite(testCases: ISZ[(Z, ISZ[ST])]): Unit = {
    val tq = "\"\"\""

    val testRoot = Os.path(".") / "src" / "test" / "bridge"

    val VVI_i_pp_t_id = Arch.PG_i_Instance_pp_t.id
    val RateControl_pp_rc_id = Arch.PG_i_Instance_pp_rc.id

    def genUniqueSuiteName(path: Os.Path, prefix: String): String = {
      var i = 0
      while(true) {
        val cand = path / s"${prefix}_${i}.scala"
        if (!cand.exists) {
          return s"${prefix}_${i}"
        }
        i = i + 1
      }
      halt("Infeasible")
    }

    for (p <- testCases) {
      art.Art.BridgeId.fromZ(p._1) match {
        case VVI_i_pp_t_id =>
          val prefix = "VVI_i_pp_t_RM_TestSuite"
          val path = testRoot /+ ISZ("bless","vvi_mode")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package bless.vvi_mode
                |
                |import org.sireum._
                |import bless.vvi_mode._
                |
                |class ${suiteName} extends VVI_i_pp_t_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case RateControl_pp_rc_id =>
          val prefix = "RateControl_pp_rc_RM_TestSuite"
          val path = testRoot /+ ISZ("bless","vvi_mode")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package bless.vvi_mode
                |
                |import org.sireum._
                |import bless.vvi_mode._
                |
                |class ${suiteName} extends RateControl_pp_rc_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = true
                |
                |  var i = 0 // ensures generated test case names are unique
                |  def incrementI: Int = {
                |    i += 1
                |    return i
                |  }
                |
                |  ${(p._2, "\nincrementI\n\n")}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case x => halt(s"Infeasible bridge id: $x")
      }
    }
  }

  def genTestCase(observationKind: ObservationKind.Type, preContainer: Option[String], postContainer: Option[String], testNameSuffix: Option[String]): ST = {
    val tq = "\"\"\""
    val suffix: String =
      if (testNameSuffix.nonEmpty) testNameSuffix.get
      else ""

    observationKind match {


      case _ => return st"// TODO ${observationKind}"
    }
  }

  def getUpdates(bridge_id: art.Art.BridgeId, observationKind: ObservationKind.Type, container: art.DataContent): Map[String, String] = {
    observationKind match {
      case bless.runtimemonitor.ObservationKind.PG_i_Instance_pp_t_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bless.vvi_mode.VVI_i_pp_t_PostState_Container_PS]
        if (postContainer.api_p.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_p" ~> postContainer.api_p.get.string
        }
        if (postContainer.api_n.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_n" ~> postContainer.api_n.get.string
        }
        return updates
      case bless.runtimemonitor.ObservationKind.PG_i_Instance_pp_rc_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bless.vvi_mode.RateControl_pp_rc_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_lrl" ~> postContainer.api_lrl.string
        updates = updates + s"${bridge_id}_Out_vrp" ~> postContainer.api_vrp.string
        return updates
      case bless.runtimemonitor.ObservationKind.PG_i_Instance_pp_t_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[bless.vvi_mode.VVI_i_pp_t_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_lrl" ~> preContainer.api_lrl.string
        updates = updates + s"${bridge_id}_In_vrp" ~> preContainer.api_vrp.string
        if (preContainer.api_s.nonEmpty) {
          updates = updates + s"${bridge_id}_In_s" ~> preContainer.api_s.get.string
        }
        if (preContainer.api_h.nonEmpty) {
          updates = updates + s"${bridge_id}_In_h" ~> preContainer.api_h.get.string
        }
        return updates
      case bless.runtimemonitor.ObservationKind.PG_i_Instance_pp_rc_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[bless.vvi_mode.RateControl_pp_rc_PreState_Container_PS]
        return updates
      case bless.runtimemonitor.ObservationKind.PG_i_Instance_pp_t_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bless.vvi_mode.VVI_i_pp_t_PostState_Container_PS]
        if (postContainer.api_p.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_p" ~> postContainer.api_p.get.string
        }
        if (postContainer.api_n.nonEmpty) {
          updates = updates + s"${bridge_id}_Out_n" ~> postContainer.api_n.get.string
        }
        return updates
      case bless.runtimemonitor.ObservationKind.PG_i_Instance_pp_rc_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[bless.vvi_mode.RateControl_pp_rc_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_lrl" ~> postContainer.api_lrl.string
        updates = updates + s"${bridge_id}_Out_vrp" ~> postContainer.api_vrp.string
        return updates
      case _ => return Map.empty
    }
  }
}