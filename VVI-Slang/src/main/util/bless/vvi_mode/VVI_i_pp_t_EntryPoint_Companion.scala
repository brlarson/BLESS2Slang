// #Sireum

package bless.vvi_mode

import org.sireum._
import art._
import bless._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

object VVI_i_pp_t_EntryPoint_Companion {

  var preStateContainer_wL: Option[VVI_i_pp_t_PreState_Container_PS] = None()

  def pre_initialise(): Unit = {
    // assume/require contracts cannot refer to incoming ports or
    // state variables so nothing to do here
  }

  def post_initialise(): Unit = {
    // block the component while its post-state values are retrieved
    val postStateContainer_wL =
      VVI_i_pp_t_PostState_Container_PS(
        api_n = Art.observeOutPortVariable(Arch.PG_i_Instance_pp_t.operational_api.n_Id).asInstanceOf[Option[art.Empty]],
        api_p = Art.observeOutPortVariable(Arch.PG_i_Instance_pp_t.operational_api.p_Id).asInstanceOf[Option[art.Empty]])

    // the rest can now be performed via a different thread
    bless.runtimemonitor.RuntimeMonitor.observeInitialisePostState(Arch.PG_i_Instance_pp_t.id, bless.runtimemonitor.ObservationKind.PG_i_Instance_pp_t_postInit, postStateContainer_wL)
  }

  def pre_compute(): Unit = {
    // block the component while its pre-state values are retrieved
    preStateContainer_wL = Some(
      VVI_i_pp_t_PreState_Container_PS(
        api_h = Art.observeInPortVariable(Arch.PG_i_Instance_pp_t.operational_api.h_Id).asInstanceOf[Option[art.Empty]], 
        api_s = Art.observeInPortVariable(Arch.PG_i_Instance_pp_t.operational_api.s_Id).asInstanceOf[Option[art.Empty]], 
        api_lrl = Art.observeInPortVariable(Arch.PG_i_Instance_pp_t.operational_api.lrl_Id).get.asInstanceOf[vvi_mode.CardiacDuration_Payload].value, 
        api_vrp = Art.observeInPortVariable(Arch.PG_i_Instance_pp_t.operational_api.vrp_Id).get.asInstanceOf[vvi_mode.CardiacDuration_Payload].value))

    // the rest can now be performed via a different thread
    bless.runtimemonitor.RuntimeMonitor.observeComputePreState(Arch.PG_i_Instance_pp_t.id, bless.runtimemonitor.ObservationKind.PG_i_Instance_pp_t_preCompute, preStateContainer_wL.asInstanceOf[Option[art.DataContent]])
  }

  def post_compute(): Unit = {
    // block the component while its post-state values are retrieved
    val postStateContainer_wL =
      VVI_i_pp_t_PostState_Container_PS(
        api_n = Art.observeOutPortVariable(Arch.PG_i_Instance_pp_t.operational_api.n_Id).asInstanceOf[Option[art.Empty]],
        api_p = Art.observeOutPortVariable(Arch.PG_i_Instance_pp_t.operational_api.p_Id).asInstanceOf[Option[art.Empty]])

    // the rest can now be performed via a different thread
    bless.runtimemonitor.RuntimeMonitor.observeComputePrePostState(Arch.PG_i_Instance_pp_t.id, bless.runtimemonitor.ObservationKind.PG_i_Instance_pp_t_postCompute, preStateContainer_wL.asInstanceOf[Option[art.DataContent]], postStateContainer_wL)
  }
}