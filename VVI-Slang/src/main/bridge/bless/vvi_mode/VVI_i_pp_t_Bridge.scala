// #Sireum

package bless.vvi_mode

import org.sireum._
import art._
import bless._
import bless.vvi_mode.{VVI_i_pp_t => component}
import org.sireum.S64._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

@datatype class VVI_i_pp_t_Bridge(
  val id: Art.BridgeId,
  val name: String,
  val dispatchProtocol: DispatchPropertyProtocol,
  val dispatchTriggers: Option[ISZ[Art.PortId]],

  lrl: Port[vvi_mode.CardiacDuration],
  vrp: Port[vvi_mode.CardiacDuration],
  s: Port[art.Empty],
  p: Port[art.Empty],
  n: Port[art.Empty],
  h: Port[art.Empty]
  ) extends Bridge {

  val ports : Bridge.Ports = Bridge.Ports(
    dataIns = ISZ[art.UPort](lrl,
                             vrp),

    dataOuts = ISZ[art.UPort](),

    eventIns = ISZ[art.UPort](s,
                              h),

    eventOuts = ISZ[art.UPort](p,
                               n)
  )

  val initialization_api : VVI_i_Initialization_Api = {
    val api = VVI_i_Initialization_Api(
      id,
      lrl.id,
      vrp.id,
      s.id,
      p.id,
      n.id,
      h.id
    )
    VVI_i_pp_t_Bridge.c_initialization_api = Some(api)
    api
  }

  val operational_api : VVI_i_Operational_Api = {
    val api = VVI_i_Operational_Api(
      id,
      lrl.id,
      vrp.id,
      s.id,
      p.id,
      n.id,
      h.id
    )
    VVI_i_pp_t_Bridge.c_operational_api = Some(api)
    api
  }

  val entryPoints : Bridge.EntryPoints =
    VVI_i_pp_t_Bridge.EntryPoints(
      id,

      lrl.id,
      vrp.id,
      s.id,
      p.id,
      n.id,
      h.id,

      dispatchTriggers,

      initialization_api,
      operational_api)
}

object VVI_i_pp_t_Bridge {

  var c_initialization_api: Option[VVI_i_Initialization_Api] = None()
  var c_operational_api: Option[VVI_i_Operational_Api] = None()
  // I'm a companion object block

  def contains(isz : ISZ[Art.PortId], elt : Art.PortId) : B =
    { for ( i <- isz )
      { if (i == elt) { return T } }
    return F
    }

  var event_set : Set[Art.PortId] = Set.empty[Art.PortId]

  var timeout_id : Art.PortId = Art.PortId.fromZ(Art.numPorts - 3)

  //timeout variables
  val timeout_n_p_lrl_ID : Art.PortId = timeout_id+Art.PortId.fromZ(1)
  var timeout_n_p_lrl_Duration : Art.Time = s64"0"


  //timeout callback classes
  @datatype class Callback_timeout_n_p_lrl(ep : EntryPoints) extends TimerCallback
    {
    override def callback(): Unit = { ep.timeout_n_p_lrl_expires( mc = this ) }
    }


  @datatype class EntryPoints(
    VVI_i_pp_t_BridgeId : Art.BridgeId,
    lrl_Id : Art.PortId,
    vrp_Id : Art.PortId,
    s_Id : Art.PortId,
    p_Id : Art.PortId,
    n_Id : Art.PortId,
    h_Id : Art.PortId,
    dispatchTriggers : Option[ISZ[Art.PortId]],
    initialization_api: VVI_i_Initialization_Api,
    operational_api: VVI_i_Operational_Api) extends Bridge.EntryPoints {

    val dataInPortIds: ISZ[Art.PortId] = IS(lrl_Id,
                                            vrp_Id)

    val eventInPortIds: ISZ[Art.PortId] = IS(s_Id,
                                             h_Id)

    val dataOutPortIds: ISZ[Art.PortId] = IS()

    val eventOutPortIds: ISZ[Art.PortId] = IS(p_Id,
                                              n_Id)

    //timeout callback methods
    def timeout_n_p_lrl_expires(mc: Callback_timeout_n_p_lrl): Unit =
      {
      operational_api.logDebug("timeout_n_p_lrl expires")
      event_set = event_set + timeout_n_p_lrl_ID
      compute()
      }

    def initialise(): Unit = {
      // i'm an initialize body
        initialization_api.logDebug("VVI_i_pp_t_Bridge.initialise()")  
        component.Initialize_Entrypoint(initialization_api)
        if ( Art.observeOutPortVariable(n_Id).nonEmpty | Art.observeOutPortVariable(p_Id).nonEmpty )
          { ArtTimer.scheduleTrait("timeout_n_p_lrl", T, timeout_n_p_lrl_Duration, Callback_timeout_n_p_lrl(this)) }
        Art.sendOutput(eventOutPortIds, dataOutPortIds)
    }

    def compute(): Unit = {
      // i'm a compute body
        operational_api.logDebug("VVI_i_pp_t_Bridge.compute()")  
        val EventTriggered(receivedEvents) = Art.dispatchStatus(VVI_i_pp_t_BridgeId)
        event_set = event_set ++ receivedEvents  
        Art.receiveInput(eventInPortIds, dataInPortIds)
        val dispatched : B = { component.Compute_Entrypoint(operational_api, event_set) }
        if (dispatched) { event_set = Set.empty[Art.PortId] }
        if ( Art.observeOutPortVariable(n_Id).nonEmpty | Art.observeOutPortVariable(p_Id).nonEmpty )
          { ArtTimer.scheduleTrait("timeout_n_p_lrl", T, timeout_n_p_lrl_Duration, Callback_timeout_n_p_lrl(this)) }
        Art.sendOutput(eventOutPortIds, dataOutPortIds)
    }

    def finalise(): Unit = {
      // i'm a finalize body
      Art.receiveInput(eventInPortIds, dataInPortIds)
      component.Finalize_Entrypoint(operational_api)
    }

    override
    def testInitialise(): Unit = {
      // i'm an initialize body
        initialization_api.logDebug("VVI_i_pp_t_Bridge.initialise()")  
        component.Initialize_Entrypoint(initialization_api)
        if ( Art.observeOutPortVariable(n_Id).nonEmpty | Art.observeOutPortVariable(p_Id).nonEmpty )
          { ArtTimer.scheduleTrait("timeout_n_p_lrl", T, timeout_n_p_lrl_Duration, Callback_timeout_n_p_lrl(this)) }
        Art.sendOutput(eventOutPortIds, dataOutPortIds)
    }

    override
    def testCompute(): Unit = {
      // i'm a compute body
        operational_api.logDebug("VVI_i_pp_t_Bridge.compute()")  
        val EventTriggered(receivedEvents) = Art.dispatchStatus(VVI_i_pp_t_BridgeId)
        event_set = event_set ++ receivedEvents  
        Art.receiveInput(eventInPortIds, dataInPortIds)
        val dispatched : B = { component.Compute_Entrypoint(operational_api, event_set) }
        if (dispatched) { event_set = Set.empty[Art.PortId] }
        if ( Art.observeOutPortVariable(n_Id).nonEmpty | Art.observeOutPortVariable(p_Id).nonEmpty )
          { ArtTimer.scheduleTrait("timeout_n_p_lrl", T, timeout_n_p_lrl_Duration, Callback_timeout_n_p_lrl(this)) }
        Art.sendOutput(eventOutPortIds, dataOutPortIds)
    }
  }
}